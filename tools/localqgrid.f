c localqgrid.f
C computes the Fourier transform of the Local potential generated by martin.f 
c
c The Fourier transform of Vlocal is:
c vlocal(q)= int(all space) exp(i*q*r) vlocal(r) d3r is
c        4*pi * FF[L,uL,q] 
c where FF= int(0,inf) j0(qr) * r*r * uL(r) dr.
c
c This program computes vlocal(q) defined above. vlocal is read in as eV,A
c units, so we use eV A units thorughout.
c
c In a solid, <q1| V(r) | q2> = 1/vc sum(b) exp(i*(q2-q1)*b) vlocal(q2-q1).
c
c
c Feb. 27, 1993 ---  Saturday
c
c
c
c ===============================================================
c O.F. Sankey, arizona state University, Dept. of physics and astronomy
c Tempe, AZ 85287   602 965-4334  sankey@edison.la.asu.edu
c FAX 602 965-7954
c ================================================================
c
C THIS PROGRAM SETS UP THE ONE-DIMENSIONAL GRID 
c
c The results are written to a file containing nq points.
C
        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        REAL*8 JL
	parameter (nrmax=17007, nqmax=17007)
	parameter (nmaxLOG=9808)
	dimension rLog(nmaxLog),vLog(nmaxLog)
	CHARACTER*30 filein
        character*60 mess60(2)
        character*20 mess20(0:10)
        character*30 mess30(0:10)
	character*35 mess35(3)
        character*40 mess40

	character*30 iname,idate,mess30x
	dimension r(nrmax),simpson(nrmax),q(nqmax)
	dimension Lvalue(10),rmatch(10),eigen(10)
	dimension vlocalR(nrmax),vlocalQ(nqmax),vlocalSR(nrmax)
	dimension vcore(nrmax)
	
c ===============================================================
C constants
        pi=4.D0*DATAN(1.D0)
	EQ2=14.39975D0
	abohr=0.529177D0
	HARTREE=EQ2/ABOHR
	ryd=hartree/2.0d0
c ===============================================================
	write(*,*)'  '
        WRITE(*,*)'                      WELCOME'
        WRITE(*,*)' PROGRAM  localqgrid: Fourier transform of ',
     1  ' local potential output from martins.f'
        WRITE(*,*)'  '
        WRITE(*,*)' '
C ===========================================================
	write(*,*)' Open the data file containing vlocal --'
	write(*,*)' it is Local.dat'
	mess60(1)=' Otto Sankey '
	mess60(2)=' LRlocal.dat'
	mess20(0)=' Number of states.'
	do i=1,10
	mess20(i)   ='=L;   gncppO'
	end do
	mess40   =' localqgrid March 98'
c	write(*,*)' insert zval'
c	read(*,*)zval
c	write(*,*)' zval=',zval
c
cotto        open(unit=47,file='Local.dat',status='old')
c
cotto        read(47,7188)mess60(1)
cotto	write(*,7188)mess60(1)
7188    format(a60)
cotto        read(47,7192)Llocal,mess60(2)
cotto        write(*,7192)Llocal,mess60(2)
7192    format(i4,a60)

c
cotto        read(47,7186)nznuc,zval,mess40
cotto        write(*,7186)nznuc,zval,mess40
7186     format(i4,f9.4,a40)
c
cotto        read(47,7189)nstate,mess20(0)
cotto        write(*,7189)nstate,mess20(0)
7189    format(i4,a20)
c
	rcutav=0.0d0
c        do iwave=1,nstate
cotto        read(47,7190)Lvalue(iwave),mess20(iwave)
cotto        read(47,7191)rmatch(iwave),eigen(iwave),mess30(iwave)
cotto        write(*,7190)Lvalue(iwave),mess20(iwave)
cotto        write(*,7191)rmatch(iwave),eigen(iwave),mess30(iwave)
cotto	rcutav=rcutav+rmatch(iwave)
cotto        end do
	open(unit=30,file='rmatch.dat',status='old')
	read(30,*)zin,zv
	zval=zv
	nzval=int(zval+0.00001)
	znuc=zin
	nznuc=int(znuc+0.00001)
	write(*,*)' atomic Z=',nznuc,' Valence Z=',nzval
	write(*,*)' atomic Z=',znuc,' Valence Z=',zval
	read(30,*)Lmax
c
c        do iwave=1,nstate
c        write(30,7190)Lvalue(iwave),mess20(iwave)
c        write(30,7191)rmatch(iwave),eigen(iwave),mess30(iwave)
c        write(*,7190)Lvalue(iwave),mess20(iwave)
c        write(*,7191)rmatch(iwave),eigen(iwave),mess30(iwave)
c        end do

	rcutav=0.0
	do L=0,Lmax
	read(30,*,err=600)LL,rcut
	rcutav=rcutav+rcut
	Lvalue(L+1)=L
	rmatch(L+1)=rcut
	eigen(L+1)=0.
	mess30(L+1)=' rmatch'
	if(LL.ne.L)stop' bad LL in rmatch.'
	end do
600	write(*,*)' Lmax=',Lmax
	nstate=(Lmax+1)
	rcutav=rcutav/dfloat(nstate)
        read(30,*)Llocal
        write(*,*)' The local potential is L=',Llocal

	close(unit=30)

7190    format(i4,a20)
7191    format(2f12.6,a30)
c open pseudoL.dat
	if(Llocal.eq.0)open(unit=30,file='pseudo0.dat',status='old')
	if(Llocal.eq.1)open(unit=30,file='pseudo1.dat',status='old')
	if(Llocal.eq.2)open(unit=30,file='pseudo2.dat',status='old')
	if(Llocal.eq.3)open(unit=30,file='pseudo3.dat',status='old')
	if(Llocal.eq.4)open(unit=30,file='pseudo4.dat',status='old')
	read(30,*)
	
	do i=2,10000
	read(30,*,err=601)j,rLog(i),psi,VLog(i)
	VLog(i)=VLog(i)*Hartree
	rLog(i)=rLog(i)*abohr
	Numb=i
	if(j.ne.i-1)stop' j.ne. i in pseudoL.dat'
	end do
601	write(*,*)' Numb=',Numb,' points read in.'
	if(Numb.gt.nmaxLog)stop ' Numb.gt.nmaxLog'
	Rmax=rLog(Numb)
	write(*,*)' Rmax=',Rmax
	rLog(1)=0.0
	VLog(1)=VLog(2)
	close(unit=30)
c otto
        do i=1,nrmax-1
        x=0.9999999d0*rmax*(float(i-1))/float(nrmax-1-1)
        norder=5
        call polyint(rLog,Vlog,nmaxLog,numb,norder,x,y,dy)
        r(i)=x
        VlocalR(i)=y
c        write(30,*)x,y
        end do
        mesh=nrmax-1
       nr=mesh-1
       write(*,*)' nr=',nr


	


c	read(47,*)mesh
c	write(*,*)' number of r points=',mesh
c	nr=mesh
c	write(*,*)' nr=',nr
c	write(*,*)' Would you lioke to reduce this?'
c	write(*,*)' Any negative number uses the old value!'
c	write(*,*)' Insert the new mesh'
c	read(*,*)meshnew
c	write(*,*)' Newmesh=',meshnew
c	if(meshnew.lt.0)then
c	write(*,*)' Using OLD mesh.'
c	meshnew=mesh
c	end if
c	mesh=meshnew
c	write(*,*)'  '
c	write(*,*)' The mesh we use=',mesh
c	nr=mesh
c	if(mesh.gt.nrmax)then
c	write(*,*)' mesh=',mesh
c	write(*,*)' nrmax=',nrmax
c	write(*,*)' Increase dimension nrmax'
c	stop' sorry abort'
c	end if
c
c        do i=1,mesh
c        read(47,*)r(i),vlocalR(i)
c        end do
c        close(unit=47)
	write(*,*)' '
c	write(*,*)' Close Local.dat'
	write(*,*)'  '
	write(*,*)' Caution -- rcutav in abohr!!!'
	write(*,*)' Currently rcutav=',rcutav
	write(*,*)' Insert new value for rcutav.'
	write(*,*)' The current value may be OK, so if'
	write(*,*)' youre not sure, then insert this value'
	write(*,*)' Insert new value of rcutav........'
	write(*,*)'  '
	write(*,*)' Insert -1 to use the above default value'
	rcutdefault=rcutav
	write(*,*)'  '
c	read(*,*)rcutav
	rcutav=-1.
	write(*,*)rcutav
	if(rcutav.lt.-0.99.and.rcutav.gt.-1.01)rcutav=rcutdefault
	write(*,*)' New rcutav=',rcutav
c ====================================================================
	write(*,*)' Some information for output file LocalQ.dat'
        write(*,*)' Input name of atom, e.g. carbon'
c        read(*,809)iname
	iname='=============================='
809     format(a30)
        write(*,809)iname
	idate=' Otto Sankey'
        write(*,*)' Insert date'
c       read(*,809)idate
        write(*,809)idate
c ===============================================================
c we use nrmax-1 since for simpsons rule we need an odd number of
c points and sometimes we pad the data with an extra points of zero.
	if(nr.gt.nrmax-1)stop' too many points!'
	rmin=r(1)
	rmax=r(nr)
	dr=r(2)-r(1)
c the points are assumed to be equally spaced. lets check!
	if(dabs(  ((rmax-rmin)/dfloat(nr-1)) -dr ).gt.0.000001)
     1	stop' points are not equally space!'
c ===============================================================
c set up factors for simpson's rule.
	do 22 ir=1,nr
	simpson(ir)=dr*4.d0/3.d0
	if(mod(ir,2).eq.1)simpson(ir)=dr*2.d0/3.d0
22	continue
	simpson(1)=dr*1.d0/3.d0
c nr must be odd for simpsons rule to work. If it is not odd, then we
c add one more point withthe function being zero!
	if(mod(nr,2).eq.0)then
	nr=nr+1
	r(nr)=rmax+dr
	vlocalR(nr)=0.0d0
	end if
	simpson(nr)=dr*1.d0/3.d0
	sq4pi=dsqrt(4.d0*pi)
c ===============================================================
c check asymptote of vlocalR. it should go as -Ze**2/r
	write(*,*)'  '
	write(*,*)' Check asymptote of potential'
	write(*,*)' It should go as -Z*e**2/r'
	write(*,*)' Lets find Z and compare with zval'
	write(*,*)' vlocal(nr-2)=',vlocalR(nr-2)
	write(*,*)' r(nr-2)=',r(nr-2)
	write(*,*)' eq2=',eq2
	write(*,*)' nr=',nr
	Zeff=-vlocalR(nr-2)*r(nr-2)/eq2
	write(*,*)' Zeff=',Zeff
	write(*,*)' zval=',zval
	if(dabs(Zeff-zval).gt.0.002)stop' Z"s not close enough'
c	if(dabs(Zeff-zval).gt.0.0001)stop' Z"s not close enough'
c	istop=1
c	if(istop.eq.1)stop' stop due to istop'
c ================================================================
c The potential iss an analytic part (an erf part) and a numerical
c part. The analytic part is so that we can take a fourier transform
c of the long-ranged 1/r part.
c        RMAX=4.*RCUTAV
c ================================================================
c read in input file name.
        WRITE(*,*)'  '
        izero=0
C CORE POTENTIAL
C ANALYTIC EXPRESION FOR A'S  AND C'S
        ppP=4.D0
        qqQ=3.D0
	ppP=3.0
	qqQ=2.0
        write(*,*)' p and q determine the general shape of the'
        write(*,*)' long-ranged erf form of the potential.'
        write(*,*)'  '
        write(*,*)' the erf form of the long ranged potential is'
        write(*,*)' set to q*(z/rcutav) at r=0.'
        write(*,*)'  '
        write(*,*)' p is like q but for just one of the erf terms'
        write(*,*)' Normally, p>q and q>1.0'
        write(*,*)' standard values for p,q are',ppP,qqQ
        write(*,*)' another good choice is p,q=3,2'
c        write(*,*)' insert new p,q....'
c        read(*,*)ppP,qqQ
        write(*,*)' p,q=',ppP,qqQ
        if(ppP.lt.qqQ)stop ' bad p and q'                     
        write(*,*)' '


        write(*,*)' '
        write(*,*)'  '
        write(*,*)' compute core potential'
        CALL CORPMS(ppP,qqQ,C1,C2,B1,B2)
        A1=(B1/RCUTAV)**2
        A2=(B2/RCUTAV)**2
C CORE IS ARBITRARY SO LETS ROUND OFF NUMBERS
        C1=ROUND(3,C1)
        C2=1.D0-C1
        A1=ROUND(2,A1)
        A2=ROUND(2,A2)
c
c ================================================================
c we now determine how many q points and how large is qmax.
        write(*,*)'  '
        write(*,*)' we now determine the q-grid. We need to decide'
        write(*,*)' how many q points and how large qmax is.'
        write(*,*)'  '
        write(*,*)'  insert # of q points. 1001 is a good choice'
c        read(*,*)nq
	nq=4001
        write(*,*)' nq=',nq
        if(nq.gt.nqmax)stop' too many q points -- please redimension'
        WRITE(*,*)'  '
        write(*,*)' Determine qmax. use hbar**2 qmax**2 /2mecut'
        write(*,*)' to determine ecut.'
        WRITE(*,*)' INSERT ENERGY CUTOFF IN EV. (500 or 1000 for Si.)'
c        READ(*,*)ECUT
	Ecut=2000.0
        WRITE(*,*)' ECUT=',ECUT
C FACTR= HBAR**2/2M=7.62/2. EV*ANG**2
        FACTR=7.62D0/2.
        QMAX=DSQRT( ECUT/FACTR)
        WRITE(*,*)'  '
        WRITE(*,*)' QMAX (Angstrom)=',QMAX
        WRITE(*,*)'  '
        WRITE(*,*)'  '
c ===============================================================

c ================================================================
C PUT PSEUDOPOTENTIAL PARAMETERS IN FILE 80, LRlocal.dat
        write(*,*)'  '
        write(*,*)' core parameters written to file corepart.dat'
        open(unit=30,FILE='LRlocal.dat',STATUS='UNKNOWN')
        WRITE(30,322)C1,C2,A1,A2
322     FORMAT(2F8.3,2F8.2)
c ===============
        write(30,7188)mess60(1)
        write(*,7188)mess60(1)
        write(30,7192)Llocal,mess60(2)
        write(*,7192)Llocal,mess60(2)
c
        write(30,7186)nznuc,zval,mess40
        write(*,7186)nznuc,zval,mess40
c
        write(30,7189)nstate,mess20(0)
        write(*,7189)nstate,mess20(0)

        do iwave=1,nstate
        write(30,7190)Lvalue(iwave),mess20(iwave)
        write(30,7191)rmatch(iwave),eigen(iwave),mess30(iwave)
        write(*,7190)Lvalue(iwave),mess20(iwave)
        write(*,7191)rmatch(iwave),eigen(iwave),mess30(iwave)
        end do
        write(30,809)iname
        write(30,809)idate
        write(30,*)ecut
        write(30,*)qmax
        write(30,*)nq
	write(30,*)rcutav
c ===============
        close(unit=30)
        WRITE(*,*)' '
        WRITE(*,*)' THE CORE PARAMETERS ARE'
        WRITE(*,*)' C1=',C1,' C2=',C2
        WRITE(*,*)' A1=',A1,' A2=',A2
        WRITE(*,*)'  '
c ================================================================
C NOW PUT VCOR TOGETHER AT EACH R POINT.
c
c vcor is in hartree and abohr units!
        A1=SQRT(A1)
        A2=SQRT(A2)
c Now change a1,a2 to A units.
	a1=(1.d0/abohr)*a1
	a2=(1.d0/abohr)*a2
c We also change vcor to A, eV units.
        DO 4 I=1,nr
        IF(R(I).LT.0.00001)R(I)=0.00001
4       vcore(I)=-zval*eq2*(C1*OFSerf(A1*R(I))+
     1	C2*OFSerf(A2*R(I)))/R(I)
        WRITE(*,*)' vcore(1) at origin=',vcore(1),' vcore(2)=',vcore(2)
        write(*,*)'  '
        write(*,*)' finished with core potential'
        write(*,*)'  '
c 
c Now subtract off vcore from vlocal to find the "true" vlocal'
	nx=nr/20
	nrnew=0
	rmaxnew=0.0
	rOKtol=1.0d-06
c	do i=1,nr
c	write(*,829)i,r(i),vlocalr(i),vcore(i)
c829	format(' i,r,vlocal,vcore=',i6,3f12.8)
c	end do
        DO 9 I=1,nr
        vlocalSR(I)=vlocalR(I)-vcore(I)
c	if(i.gt.nr/4.and.abs(vlocalSR(i))/abs(vlocalR(i)).le.1d-07)then
	if(i.gt.nr/4.and.abs(vlocalSR(i))/abs(vlocalR(i)).le.rOKtol)then
	if(nrnew.ne.0)go to 813
	nrnew=i
	rmaxnew=r(i)
813	continue
	end if
        if(mod(i,nx).eq.1)then
c        write(*,*)'  '
	write(*,819)i,r(i),vlocalR(i),vcore(i),vlocalSR(i)
819	format(i5,' r=',f9.4,' vlocal=',e15.6,' =LR+SR=',2e15.6)
        end if
9       CONTINUE
	write(*,*)'  '
	write(*,*)' Based on this it looks like vlocalSR(i) goes to'
	write(*,*)' zero safely past r=',rmaxnew,' at nrnew=',nrnew
c	write(*,*)' Insert new number of r points (usually nrnew above)'
c	write(*,*)' Insert -1 and we will use the SAFE point given above'
c	read(*,*)nrnewnew
c	write(*,*)nrnewnew
	nrnewnew=-1
	if(nrnewnew.eq.-1)nrnewnew=nrnew
c	write(*,*)' nrnewnew=',nrnewnew
c        write(*,*)' '
	nrnew=nrnewnew
	write(*,*)' the new nr=',nrnew

c ===============================================================
c set up factors for simpson's rule.
	rmax=r(nrnew)
        do 1322 ir=1,nrnew
        simpson(ir)=dr*4.d0/3.d0
        if(mod(ir,2).eq.1)simpson(ir)=dr*2.d0/3.d0
1322     continue
        simpson(1)=dr*1.d0/3.d0
c nr must be odd for simpsons rule to work. If it is not odd, then we
c add one more point withthe function being zero!
        if(mod(nrnew,2).eq.0)then
        nrnew=nrnew+1
        r(nrnew)=rmax+dr
        vlocalSR(nrnew)=0.0d0
        end if
        simpson(nrnew)=dr*1.d0/3.d0
c ===============================================================
	write(*,*)'  '
c ===============================================================
c
c loop over all q values:
	qmin=0.0
	do 100 iq=1,nq
	q(iq)=qmin+dfloat(iq-1)*(qmax-qmin)/dfloat(nq-1)
	vlocalQ(iq)=0.0d0
c ===============================================================
c now the integral over all space.
c
	Lbessl=0
	do 200 ir=1,nrnew
	x=q(iq)*r(ir)
	arg=r(ir)*r(ir)*jl(Lbessl,x)*vlocalSR(ir)
c Notice that we put the (4*pi) in also.
	vlocalQ(iq)=vlocalQ(iq)+simpson(ir)*arg*(4.0d0*pi)
200	continue
c ===============================================================
500	continue
c write out every tenth one to the screen.
	if(mod(iq,500).eq.1)write(*,81)iq,q(iq),vlocalQ(iq)
81	format('  iq=',i5,'   q=',f9.4,' vlocalQ(iq)=',e16.6)
100	continue
c end of loop over all q values.
c ===============================================================
	write(*,*)'  '
	write(*,*)'  write out results to SRlocalQ.dat '
	write(*,*)' For plotting write to SRlocalQplot.dat'
	write(*,*)'  You should copy this output file to something more'
	write(*,*)'  permanent.'
	write(*,*)' Remember --- This result is mutiplied by 4*pi'
	write(*,*)'  '
	write(*,*)' remember: q in Angstrom. '
	write(*,*)'  '
	open(unit=30,file='SRlocalQ.dat',status='unknown')
	open(unit=38,file='SRlocalQplot.dat',status='unknown')
c ===============
        write(30,7188)mess60(1)
        write(*,7188)mess60(1)
        write(30,7192)Llocal,mess60(2)
        write(*,7192)Llocal,mess60(2)


c
        write(30,7186)nznuc,zval,mess40
        write(*,7186)nznuc,zval,mess40
c
        write(30,7189)nstate,mess20(0)
        write(*,7189)nstate,mess20(0)
c
        do iwave=1,nstate
        write(30,7190)Lvalue(iwave),mess20(iwave)
        write(30,7191)rmatch(iwave),eigen(iwave),mess30(iwave)
        write(*,7190)Lvalue(iwave),mess20(iwave)
        write(*,7191)rmatch(iwave),eigen(iwave),mess30(iwave)
        end do
	write(30,809)iname
	write(30,809)idate
	write(30,*)ecut
	write(30,*)qmax
	write(30,*)nq
	write(30,*)rcutav
7195	format(e16.6,a35)
	mess35(1)=' is the potential a q=0'
	write(30,7195)vlocalQ(1),mess35(1)
c ===============
c
c
	do 40 iq=1,nq
c
	write(30,41)q(iq),vlocalQ(iq)
c For plotting
	write(38,*)q(iq),vlocalQ(iq)
c
41	format(2e18.9)
40	continue
	close(unit=30)
	close(unit=38)

c write out vlocalSR.
	write(*,*)'  '
	open(unit=82,file='SRlocalR.dat',status='unknown')
        DO 79 I=1,nr
	write(82,*)r(i),vlocalSR(i)
79	continue
	close(unit=82)
        write(*,*)' '

	write(*,*)'   '
	write(*,*)' Reminder -------'
	write(*,*)' Long-ranged (LR) erf part written to:'
	write(*,*)'                          LRlocal.dat'
	write(*,*)' Short ranged (SR) part in q space written to:'
	write(*,*)'                          SRlocalQ.dat'
	write(*,*)'                          SRlocalQplot.dat'
	write(*,*)' Short ranged (SR) part in r space written to:'
	write(*,*)' (for graphs/tests)       SRlocalR.dat'
	write(*,*)'  '
	write(*,*)' Look at results IN REAL SPACE in .gnuplot style'
	write(*,*)
     1	' vlocalR(i) (Exact answer from martins) ====> junk0.dat'
	write(*,*)
     1	' vcore(i)   (LR erf part)               ====> junk1.dat'
	write(*,*)
     1	' vlocalSR(i)(SR part of local)          ====> junk2.dat'
	open(unit=70,file='junk0.dat',status='unknown')
	open(unit=71,file='junk1.dat',status='unknown')
	open(unit=72,file='junk2.dat',status='unknown')
	do i=1,nr
	write(70,*)r(i),vlocalR(i)
	write(71,*)r(i),vcore(i)
	write(72,*)r(i),vlocalSR(i)
	end do
c ===============================================================
	stop
	end
c ===============================================================
c
c
C SPHERICAL BESSEL FUNCTION
C
        FUNCTION JL(L,X)
        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        REAL*8 JL
        IF(L.EQ.0)GO TO 100
        JL=0.0D0
        RETURN
C
100     CONTINUE
C
C  L=0  J0=SINX/X
C
	XP=0.001
        IF(X.LT.XP)GO TO 1000
        JL=DSIN(X)/X
        RETURN
1000    X2=X*X
	X4=X2*X2
	JL=(1.D0-X2/6.D0+X4/120.D0)
        RETURN
        END
c ==============================================================
C ROUND.FOR-- ROUNDS VARIABLE X TO N DIGITS AFTER DECIMAL.
       FUNCTION ROUND(N,X)
       IMPLICIT REAL*8 (A-H,O-Z)
       II=10**N
       Y=X*II
       NN=Y+0.5
       Y=NN
       Z=II
       ROUND=Y/Z
       RETURN
       END
c ==============================================================
C CORPMS.FOR -FIND CORE POTENTIAL
        SUBROUTINE CORPMS(PP,QQ,C1,C2,B1,B2)
        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        DIMENSION ROOT(10)
        COMMON/CORPAR/P,Q
C
C INPUT VARIABLES
        P=PP
        Q=QQ
        XMIN0=.1D0
        XMAX=4.D0
        DIVD=25.D0
        WRITE(*,*)' P=',P,'  Q=',Q
        NROOTS=1
        DIVD2=6.D0
        NKUT=3
C END OF INPUT
C
C INITIALIZE
         ISTOP=0
         XMIN=XMIN0
         DEL0=(XMAX-XMIN)/DIVD
C
         DO 20 I=1,NROOTS
         IF(ISTOP.GT.0) GOTO 24
         F0=FC(XMIN)
         DEL=DEL0
         DO 21 K=1,NKUT
22       X=XMIN+DEL
         F=FC(X)
         FF0=F*F0
         SLOPE=(F-F0)/DEL
         IF(FF0.GT.0.D0) GOTO 23
         DEL=DEL/DIVD2
         ABIT=F/SLOPE
         ROOT(I)=X-ABIT
         GOTO 21
23       XMIN=XMIN+DEL
         F0=F
         IF(X.GT.XMAX) GOTO 24
         GOTO 22
21       CONTINUE
         XMIN=X+DEL
         GOTO 20
24       ISTOP=ISTOP+1
20       CONTINUE
         NROOTS=NROOTS-ISTOP
C
       SQPI=DSQRT(3.141592654D0)
       B1=ROOT(1)
       B2=(Q-P)*SQPI*B1/(2.D0*B1-SQPI*P)
       C1=SQPI*P/(2.D0*B1)
       C2=1.D0-C1
       RETURN
       END
c ==============================================================
C FUNCTION FC(B1)
       FUNCTION FC(B1)
       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
       COMMON/CORPAR/P,Q
       SQPI=DSQRT(3.141592654D0)
       DEN=2.D0*B1-SQPI*P
       IF(DABS(DEN).LT.0.00002D0) GOTO 10
       B2=(Q-P)*SQPI*B1/(2.D0*B1-SQPI*P)
       E1=OFSerf(B1)
       E2=OFSerf(B2)
       FC=B1*(2.D0*(1.D0-E2))-P*SQPI*(E1-E2)
       RETURN
 10    FC=100.D0
       RETURN
       END
c ==============================================================
        DOUBLE PRECISION FUNCTION OFSERF(X)
c       FUNCTION OFSERF(X)
C SEE ABRAMOWITZ AND STEGUN.
        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        Y=X
        IF(X.LT.0.)Y=-X
        IF(Y.LT.1.0E-7)GO TO 1
        P=0.3275911D0
c       P=0.3275911
        T=1.0/(1.0+P*Y)
        A1=0.254829592
        A2=-0.284496736
        A3=1.421413741
        A4=-1.453152027
        A5=1.061405429
        Z=1.0-(A1*T+A2*T*T+A3*(T**3)+A4*(T**4)+A5*(T**5))*EXP(-Y*Y)
        IF(X.LT.0.)Z=-Z
        IF(X.LT.0.)Z=-Z
        GO TO 2
1       Z=0.0
2       CONTINUE
        OFSERF=Z
        RETURN
        END
        double precision function OFSERFC(X)
        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        OFSERFC=1-OFSERF(X)
        RETURN
        END
